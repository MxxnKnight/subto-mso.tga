import os
import json
import logging
import requests
import io
import zipfile
import re
from flask import Flask, request, jsonify
import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from scrapper import get_soup, extract_imdb_id, scrape_detail_page

# --- Logging Setup ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Bot and Flask Setup ---
TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
if not TOKEN:
    # This is a fallback for local testing, not for production
    TOKEN = "dummy_token"
    logger.warning("TELEGRAM_BOT_TOKEN environment variable not found. Using a dummy token.")

bot = telegram.Bot(token=TOKEN)
app = Flask(__name__)

# --- Load Database ---
try:
    with open('db.json', 'r', encoding='utf-8') as f:
        db = json.load(f)
    logger.info("Successfully loaded db.json.")
except FileNotFoundError:
    db = {}
    logger.warning("db.json not found. The bot will not have data to search.")
except json.JSONDecodeError:
    db = {}
    logger.error("Could not decode db.json. File might be corrupt.")

# --- Menu Content & Helpers ---
HOME_TEXT = "Welcome! Send me a movie or series name to search for subtitles."
HELP_TEXT = """
*How to use this bot:*

1\\. *Search:* Send any movie or series name\\. The bot will search for matching subtitles\\.
2\\. *Results:* If there's one match, you'll get the details directly\\. If there are multiple matches, you'll get a list of buttons to choose from\\.
3\\. *Download:* Click the 'Download Subtitle' button to get the file\\. If it's a series with multiple seasons, you can choose a season first\\.
4\\. *ZIP Files:* If the subtitle is in a ZIP file, the bot will automatically extract and send you the `\\.srt` file\\(s\\)\\.
"""
ABOUT_TEXT = """
*About This Bot*

- *Hosted on:* Render
- *Library:* python\\-telegram\\-bot
- *Database:* A simple `db\\.json` file generated by the scraper\\.
- *Owner:* You\\!
"""
TOS_TEXT = "This bot is for educational purposes only\\. Please respect the copyright of the subtitle creators\\. We do not host any files on our server\\."

def get_home_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("Help", callback_data='help'),
            InlineKeyboardButton("About", callback_data='about'),
        ],
        [
            InlineKeyboardButton("Terms of Service", callback_data='tos'),
            InlineKeyboardButton("Close", callback_data='close')
        ]
    ])

def get_back_keyboard():
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("Home", callback_data='home'),
            InlineKeyboardButton("Close", callback_data='close')
        ]
    ])

def escape_markdown_v2(text):
    """Escapes strings for Telegram's MarkdownV2 parser."""
    if not isinstance(text, str):
        return ''
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return re.sub(f'([{re.escape(escape_chars)}])', r'\\\1', text)

# --- Bot Handler Functions ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message when the /start command is issued."""
    logger.info(f"Received /start command from {update.effective_user.name}")
    await update.message.reply_text(HOME_TEXT, reply_markup=get_home_keyboard())

async def search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Searches for subtitles based on user's message."""
    query = update.message.text.lower()
    logger.info(f"Received search query: '{query}' from user {update.effective_user.name}")
    
    status_message = await update.message.reply_text("Searching...")

    results = [
        (imdb_id, entry) for imdb_id, entry in db.items() 
        if query in entry.get('title', '').lower().replace('.', ' ')
    ]
    logger.info(f"Found {len(results)} results for query: '{query}'")

    if not results:
        await status_message.edit_text(f'Sorry, no results found for "{update.message.text}".')
        return

    if len(results) == 1:
        await send_detailed_view(status_message, results[0][0])
    else:
        keyboard = []
        for imdb_id, entry in results[:10]: # Limit to 10 results
            keyboard.append([InlineKeyboardButton(entry['title'], callback_data=f"select:{imdb_id}")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await status_message.edit_text(
            f'I found multiple results for "{update.message.text}". Please select one:',
            reply_markup=reply_markup
        )

async def send_detailed_view(message, imdb_id):
    """Formats and sends the detailed view for a movie/series."""
    logger.info(f"Sending detailed view for IMDb ID: {imdb_id}")
    entry = db.get(imdb_id)
    if not entry:
        logger.warning(f"No entry found for IMDb ID: {imdb_id}")
        await message.edit_text("Sorry, I couldn't find that entry.")
        return

    title = escape_markdown_v2(entry.get('title', 'N/A'))
    poster = entry.get('posterMalayalam')
    imdb_url = entry.get('imdbURL')
    imdb_rating = escape_markdown_v2(entry.get('imdbRating', 'N/A'))
    certification = escape_markdown_v2(entry.get('certification', 'N/A'))
    release_number = escape_markdown_v2(entry.get('msoneReleaseNumber', 'N/A'))
    director = escape_markdown_v2(entry.get('director', 'N/A'))
    genre = escape_markdown_v2(entry.get('genre', 'N/A'))
    synopsis = escape_markdown_v2(entry.get('descriptionMalayalam', 'N/A'))
    poster_designer = entry.get('posterDesigner', {})

    caption = f"*{title}*\n\n"
    caption += f"`{release_number}`\n\n"
    if imdb_rating != 'N/A' or certification != 'N/A':
        caption += f"*Rating:* {imdb_rating} | *Certification:* {certification}\n"
    if director != 'N/A':
        caption += f"*Director:* {director}\n"
    if genre != 'N/A':
        caption += f"*Genre:* {genre}\n\n"

    caption += f"_{synopsis}_\n\n"

    if poster_designer and poster_designer.get('name') != 'N/A':
        designer_name = escape_markdown_v2(poster_designer.get('name'))
        caption += f"Poster by: [{designer_name}]({poster_designer.get('url')})\n"

    caption += f"\n[IMDb]({imdb_url})"

    keyboard = []
    if entry.get('isSeries') and entry.get('seasons'):
        for season in entry['seasons']:
            callback_data = f"season:{season['url']}"
            keyboard.append([InlineKeyboardButton(season['season_name'], callback_data=callback_data)])
    else:
        callback_data = f"download:{imdb_id}"
        keyboard.append([InlineKeyboardButton("Download Subtitle", callback_data=callback_data)])

    reply_markup = InlineKeyboardMarkup(keyboard)

    await message.delete()
    if poster:
        await bot.send_photo(
            chat_id=message.chat.id,
            photo=poster,
            caption=caption,
            parse_mode=ParseMode.MARKDOWN_V2,
            reply_markup=reply_markup
        )
    else:
        await bot.send_message(
            chat_id=message.chat.id,
            text=caption,
            parse_mode=ParseMode.MARKDOWN_V2,
            reply_markup=reply_markup
        )

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Parses the CallbackQuery."""
    query = update.callback_query
    await query.answer()

    data = query.data
    logger.info(f"Received callback query with data: {data}")

    action, _, value = data.partition(':')

    if action == 'close':
        await query.message.delete()
    elif action == 'home':
        await query.edit_message_text(HOME_TEXT, reply_markup=get_home_keyboard(), parse_mode=ParseMode.MARKDOWN_V2)
    elif action == 'help':
        await query.edit_message_text(HELP_TEXT, reply_markup=get_back_keyboard(), parse_mode=ParseMode.MARKDOWN_V2)
    elif action == 'about':
        await query.edit_message_text(ABOUT_TEXT, reply_markup=get_back_keyboard(), parse_mode=ParseMode.MARKDOWN_V2)
    elif action == 'tos':
        await query.edit_message_text(TOS_TEXT, reply_markup=get_back_keyboard(), parse_mode=ParseMode.MARKDOWN_V2)
    elif action == 'select':
        await send_detailed_view(query.message, value)
    elif action == 'download':
        await download_and_send(query, value, context)
    elif action == 'season':
        await handle_season_selection(query, value, context)

async def download_and_send(query, imdb_id, context):
    """Downloads and sends the subtitle file."""
    logger.info(f"Initiating download for IMDb ID: {imdb_id}")
    entry = db.get(imdb_id)
    if not entry:
        await query.edit_message_text(text="Sorry, I couldn't find that entry.")
        return

    download_url = entry.get('srtURL')
    if download_url:
        try:
            await query.edit_message_text(text="`Downloading subtitle...`", parse_mode=ParseMode.MARKDOWN_V2)
            response = requests.get(download_url)
            response.raise_for_status()

            await query.edit_message_text(text="`Uploading...`", parse_mode=ParseMode.MARKDOWN_V2)
            content_type = response.headers.get('content-type')

            if 'zip' in content_type:
                with io.BytesIO(response.content) as zip_stream:
                    with zipfile.ZipFile(zip_stream) as zip_file:
                        for file_info in zip_file.infolist():
                            if file_info.filename.endswith('.srt'):
                                with zip_file.open(file_info) as srt_file:
                                    await context.bot.send_document(
                                        chat_id=query.message.chat_id,
                                        document=srt_file.read(),
                                        filename=file_info.filename
                                    )
                await query.message.delete()
            else:
                file_name = f"{entry.get('title', 'subtitle')}.srt"
                file_stream = io.BytesIO(response.content)

                await context.bot.send_document(
                    chat_id=query.message.chat_id,
                    document=file_stream,
                    filename=file_name
                )
                await query.message.delete()
        except requests.RequestException as e:
            logger.error(f"Failed to download file: {e}")
            await query.edit_message_text(text="Sorry, I could not download the subtitle file.")

async def handle_season_selection(query, season_url, context):
    """Handles the selection of a season by scraping its page and triggering a download."""
    logger.info(f"Handling season selection for URL: {season_url}")
    await query.edit_message_text(text="`Fetching season details...`", parse_mode=ParseMode.MARKDOWN_V2)
    season_soup = get_soup(season_url)
    if season_soup:
        imdb_button = season_soup.select_one('a#imdb-button')
        if imdb_button and imdb_button.has_attr('href'):
            imdb_id = extract_imdb_id(imdb_button['href'])
            if imdb_id and imdb_id in db:
                await send_detailed_view(query.message, imdb_id)
            else:
                logger.info(f"Season not in DB, scraping on the fly: {season_url}")
                details = scrape_detail_page(season_url)
                if details:
                    # This is a temporary solution for the demo
                    await send_detailed_view_from_data(query.message, details)
                else:
                    await query.edit_message_text(text="Could not find details for this season.")
        else:
            await query.edit_message_text(text="Could not find IMDb button for this season.")
    else:
        await query.edit_message_text(text="Could not fetch season page.")

async def send_detailed_view_from_data(message, entry):
    """A version of send_detailed_view that takes data directly, for on-the-fly scraping."""
    # This is a simplified version for the demo.
    title = escape_markdown_v2(entry.get('title', 'N/A'))
    poster = entry.get('posterMalayalam')
    imdb_url = entry.get('imdbURL')
    caption = f"*{title}*\n\n[IMDb]({imdb_url})"

    imdb_id = extract_imdb_id(imdb_url)
    callback_data = f"download:{imdb_id}"
    keyboard = [[InlineKeyboardButton("Download Subtitle", callback_data=callback_data)]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message.delete()
    if poster:
        await bot.send_photo(
            chat_id=message.chat.id,
            photo=poster,
            caption=caption,
            parse_mode=ParseMode.MARKDOWN_V2,
            reply_markup=reply_markup
        )
    else:
        await bot.send_message(
            chat_id=message.chat.id,
            text=caption,
            parse_mode=ParseMode.MARKDOWN_V2,
            reply_markup=reply_markup
        )

# --- Flask API Routes ---
@app.route('/')
def index():
    logger.info("API is live and running.")
    return "API and Bot Server is running."

@app.route('/api/<imdb_id>')
def get_movie_by_id(imdb_id):
    """Serves subtitle data for a given IMDb ID."""
    movie_data = db.get(imdb_id)
    if movie_data:
        return jsonify(movie_data)
    return jsonify({"error": "Movie not found"}), 404

@app.route('/telegram', methods=['POST'])
async def webhook():
    """Webhook endpoint for the Telegram bot."""
    update = Update.de_json(request.get_json(force=True), bot)
    await application.process_update(update)
    return 'ok'

@app.route('/set_webhook', methods=['GET'])
async def set_webhook():
    """A route to manually set the webhook (for development)."""
    if TOKEN == "dummy_token":
        return "Cannot set webhook with a dummy token.", 400

    webhook_base_url = os.environ.get("WEBHOOK_URL")
    if not webhook_base_url:
        return "WEBHOOK_URL environment variable not set!", 500

    webhook_url = f'{webhook_base_url}/telegram'
    success = await bot.set_webhook(webhook_url)
    if success:
        logger.info(f"Webhook set successfully to {webhook_url}")
        return f"Webhook set to {webhook_url}"
    else:
        logger.error("Webhook setup failed!")
        return "Webhook setup failed!", 500

# --- Application Setup ---
application = Application.builder().token(TOKEN).build()
application.add_handler(CommandHandler("start", start))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, search))
application.add_handler(CallbackQueryHandler(button))

if __name__ == '__main__':
    logger.info("Starting Flask app for local development...")
    app.run(debug=True, port=5000)
